@c Copyright (C) 2021 Michaël Van Canneyt and Florian Klämpfl, 2024 Stefan-Iulian Alecu.
@c This is part of the Free Pascal User's Guide.
@c For copying conditions, see the file fpc-users-guide.texi.

@node Usage
@chapter Compiler usage

Here we describe the essentials to compile a program and a unit. For
more advanced uses of the compiler, see the section on configuring the
compiler, and the Programmer’s Guide.

The examples in this section suppose that you have an @file{fpc.cfg}
which is set up correctly, and which contains at least the path
setting for the RTL units. In principle this file is generated by the
installation program. You may have to check that it is in the correct
place. (see section 5.2 for more information on this.)

@node File searching
@section File searching

Before you start compiling a program or a series of units, it is
important to know where the compiler looks for its source files and
other files. In this section we discuss this, and we indicate how to
influence this.

@quotation Note
The use of slashes (@samp{/}) and backslashes (@samp{\}) as directory
separators is irrelevant, the compiler will convert to whatever
character is used on the current operating system. Examples will be
given using slashes, since this avoids problems on Unix systems (such as
Linux).
@end quotation

@node Command line files
@subsection Command line files

The file that you specify on the command line, such as in @command{fpc
foo.pp} will be looked for @i{only} in the current directory. If you specify
a directory in the filename, then the compiler will look in that
directory:
@example sh
fpc subdir/foo.pp
@end example
will look for foo.pp in the subdirectory @file{subdir} of the current
directory.

Under operating systems with case sensitive file systems (such as Linux
and Unix), the name of this file is case sensitive; under other
operating systems (such as DOS, Windows NT, OS/2) this is not the case.

@node Unit files
@subsection Unit files

When you compile a unit or program that needs other units, the compiler
will look for compiled versions of these units in the following
directories:

@enumerate
@item
in the current directory;
@item
in the directory where the source file resides;
@item
in the directory where the compiler binary is;
@item
in all the directories specified in the unit search path.
@end enumerate

You can add a directory to the unit search path with the @option{-Fu}
option. Every occurrence of one of these options will insert a directory
to the unit search path. i.e. the last path on the command line will be
searched first.  The compiler adds several paths to the unit search
path:

@enumerate
@item
The contents of the environment variable @env{XXUNITS}, where @var{XX}
must be replaced with one of the supported targets: GO32V2, LINUX, WIN32,
OS2, BEOS, FREEBSD, SUNOS, DARWIN (the actual list depends on the
available targets).

@item
The standard unit directory. This directory is determined from the
@env{FPCDIR} environment variable. If this variable is not set, then it
is defaulted to the following:

@itemize
@item
On Linux, @file{/usr/local/lib/fpc/FPCVERSION} or
@file{/usr/lib/fpc/FPCVERSION}, whichever is found first.
@item
On other OSes: the compiler binary directory, with @file{../} appended
to it, if it exists. For instance, on Windows, this would mean
@file{C:\FPC\2.6\units\i386-win32}, assuming the compiler was installed
in the directory @file{C:\FPC\2.6}.
@end itemize

After this directory is determined, the following paths are added to the
search path:

@itemize
@item
@file{@env{FPCDIR}/units/@env{FPCTARGET}}
@item
@file{@env{FPCDIR}/units/@env{FPCTARGET}/rtl}
@end itemize

Here, @var{FPCTARGET} must be replaced by the name of the target you are
compiling for: this is a combination of CPU and OS, so for instance, on
a 64-bit Linux system, @var{FPCTARGET} would be @samp{x86_64-linux},
resulting in the
@file{/usr/local/lib/fpc/3.2.2/units/x86_64-linux/}. Likewise, when
cross-compiling for 32-bit Windows, it would look into the
@file{/usr/local/lib/fpc/3.2.2/units/i386-win32/} directory.
@end enumerate

The @option{-Fu} option accepts a single @samp{*} wildcard, which will
be replaced by all directories found on that location, but @i{not} the
location itself. For example, given the directories:

@example
rtl/units/i386-linux
fcl/units/i386-linux
packages/base
packages/extra
@end example

@noindent the command @command{fpc -Fu"*/units/i386-linux"} will have
the same effect as @command{fpc -Furtl/units/i386-linux
-Fufcl/units/i386-linux}, since both the @file{rtl} and @file{fcl}
directories contain further @file{units/i386-linux} subdirectories. The
@file{packages} directory will not be added, since it doesn't contain a
@file{units/i386-linux} subdirectory. Likewise, the command @command{fpc
-Fu"units/i386-linux/*"} will match will match any directory below the
@file{units/i386-linux} directory, but will not match the
@file{units/i386-linux} directory itself, so you should add it manually
if you want the compiler to look for files in this directory as well:
@command{fpc -Fu"units/i386-linux" -Fu"units/i386-linux/*"}.

Note that, for optimization, the compiler will drop any non-existing paths from the
search path, i.e.  the existence of the path (after wildcard and
environment variable expansion) will be tested.

You can see what paths the compiler will search by giving the compiler
the @option{-vu} option.

Note that unit file paths specified in a config file will be added at
the end, while paths specified on the command-line are added at the
beginning.

Imagine the following command @command{fpc -n -Fu/home @@cfg -Fu/usr foo.pp},
where the file @file{cfg} has the following contents:

@example
-Fu/etc
@end example

@noindent This will result in the following search path:

@example
Using unit path: /home/
Using unit path: /usr/
Using unit path: /etc/
Using unit path: /data/FPC/installed/3.2.2/
@end example

Reverting the order of the files on the command @command{fpc -n -Fu/usr @@cfg -Fu/home foo.pp} results in:

@example
Using unit path: /usr/
Using unit path: /home/
Using unit path: /etc/
Using unit path: /data/FPC/installed/3.2.2/
@end example

Moving the position of @samp{@@cfg} will not change the path, i.e.:

@example
fpc -n -Fu/usr @@cfg -Fu/home foo.pp
@end example

@noindent and

@example
fpc -n @@cfg -Fu/usr -Fu/home foo.pp
@end example

@noindent result in the same paths being found.

On systems where filenames are case sensitive (such as Unix and Linux),
the compiler will search for:

@enumerate
@item
the original file name, i.e. preserves case;
@item
the filename all lowercased;
@item
the filename all uppercased
@end enumerate

@noindent This is necessary, since Pascal is case-insensitive, and the
statements @code{Uses Unit1;} or @code{uses unit1;} should have the same
effect. It will do this first with the extension @file{.ppu} (the
compiled unit), @file{.pp} and then with the extension @file{.pas}. For
instance, suppose that the file @file{foo.pp} needs the unit
@file{bar}. Then the command @command{fpc -Fu.. -Fuunits foo.pp} will
tell the compiler to look for the unit @file{bar} in the following places:

@itemize
@item
in the current directory;
@item
in the directory where the compiler binary is (unless under Linux);
@item
in the parent directory of the current directory;
@item
in the subdirectory units of the current directory;
@item
in the standard unit directory.
@end itemize

Also, unit names that are longer than 8 characters will first be looked
for with their full length. If the unit is not found with this name, the
name will be truncated to 8 characters, and the compiler will look again
in the same directories, but with the truncated name.

If the compiler finds the unit it needs, it will look for the source
file of this unit in the same directory where it found the unit. If it
finds the source of the unit, then it will compare the file times. If
the source file was modified more recent than the unit file, the
compiler will attempt to recompile the unit with this source file.

If the compiler doesn’t find a compiled version of the unit, or when the
@option{-B} option is specified, then the compiler will look in the same
manner for the unit source file, and attempt to recompile it.

It is recommended to set the unit search path in the configuration file
@file{fpc.cfg}. If you do this, you don’t need to specify the unit
search path on the command line every time you want to compile
something.

@node Include files
@subsection Include files

If you include a file in your source with the @code{@{$I filename@}}
directive, the compiler will look for it in the following places:

@enumerate
@item
in the path specified in the include file name;
@item
in the directory where the current source file is;
@item
in all directories specified in the include file search path.
@end enumerate

You can add files to the include file search path with the @option{-I}
or @option{-Fi} options.  As an example, consider the following include
statement in a file @file{units/foo.pp}:

@example pascal
@{$i ../bar.inc@}
@end example

@noindent Then the command @command{fpc -Iincfiles units/foo.pp} will cause the compiler to look in the following directories for @file{bar.inc}:

@enumerate
@item
the parent directory of the current directory;
@item
the @file{units} subdirectory of the current directory;
@item
the @file{incfiles} subdirectory of the current directory.
@end enumerate

@node Object files
@subsection Object files

When you link to object files, using the @code{@{$L file.o@}} directive,
the compiler will look for this file in the same way as it looks for
include files:

@enumerate
@item
in the path specified in the object file name;
@item
in the directory where the current source file isl
@item
in all directories specified in the object file search path.
@end enumerate

You can add files to the object file search path with the @option{-Fo}
option.

@node Configuration file
@subsection Configuration file

Not all options must be given on the compiler command line. The compiler
can use a configuration file which can contain the same options as on
the command line. There can be only one command line option on each
line in the configuration file.

Unless you specify the @option{-n} option, the compiler will look for a
configuration file @file{fpc.cfg} in the following places:

@itemize
@item
Under Unices (such as Linux):
@enumerate
@item
the current directory;
@item
your home directory, looking for the @file{.fpc.cfg} file;
@item
if set, the directory specified in the environment variable
@env{PPC_CONFIG_PATH};
@item
in the @file{etc} directory above the compiler directory.

For instance, if the compiler is in @file{/usr/local/bin}, it will look
in @file{/usr/local/etc}.
@end enumerate

@item
Under all other operating systems:
@enumerate
@item
the current directory;
@item
if set, the directory specified in the environment variable
@env{PPC_CONFIG_PATH};
@item
the directory where the compiler is.
@end enumerate
@end itemize

The compiler directory is determined by the location of the actual
compiler binary. This has two consequences:
@enumerate
@item
The default installation on Unix places this under
@file{/usr/local/lib/fpc}, or @file{/usr/lib/fpc}. It places several
symlinks in @file{/usr/local/bin} or @file{/usr/bin}. These symlinks are
not considered when looking for the configuration file(s), so the places
to look for the configuration file are @file{/usr/local/lib/fpc/etc}, or
@file{/usr/lib/fpc/etc}.

@item
The @command{fpc} command is not the actual compiler binary. The fpc
command selects the actual compiler binary based on e.g. the CPU
target. The actual compiler binary is called @command{ppcXYZ}
(e.g. @command{ppcx64} for x86_64).

@item
The actual installation directory may vary: @file{/usr/local/bin} may be
@file{/usr/bin}, depending on the packager.
@end enumerate

@node About long filenames
@subsection About long filenames

Free Pascal can handle long filenames on all platforms, except DOS. On
Windows, it will use support for long filenames if it is available
(which is not always the case on older versions of Windows).  If no
support for long filenames is present, it will truncate unit names to 8
characters.  It is not recommended to put units in directories that
contain spaces in their names, since the external GNU linker doesn’t
understand such filenames.

@node Compiling a program
@section Compiling a program

Compiling a program is very simple. Assuming that you have a program
source in the file @file{prog.pp}, you can compile this with the
following command:

@example sh
fpc [options] prog.pp
@end example

@noindent The square brackets indicate that what is between them is
optional.

If your program file has the @file{.pp} or @file{.pas} extension, you
can omit this on the command line, e.g. in the previous example you
could have typed:

@example sh
fpc [options] prog
@end example

If all went well, the compiler will produce an executable file. You can
execute it straight away; you don’t need to do anything else.

You will notice that there is also another file in your directory, with
extension @file{.o}. This contains the object file for your program. If
you compiled a program, you can delete the object file (@file{.o}), but
don’t delete it if you compiled a unit. This is because the unit object
file contains the code of the unit, and will be linked in any program
that uses it.

@node Compiling a unit
@section Compiling a unit

Compiling a unit is not essentially different from compiling a
program. The difference is mainly that the linker isn’t called in this
case.

To compile a unit in the file foo.pp, just type @command{fpc
foo}. Recall the remark about file extensions in the previous section.
When all went well, you will be left with two unit files:

@enumerate
@item
@file{foo.ppu}, describing the unit you just compiled;
@item
@file{foo.o}, containing the actual code of the unit; it will eventually
end up in the executables.
@end enumerate

Both files are needed if you plan to use the unit for some programs, so
do not delete them. If you want to distribute the unit, you must provide
both the @file{.ppu} and @file{.o} file. One is useless without the
other.

@c I can't use a comma in the node name, so I have to resort to this.
@node Units and libs and smartlinking
@section Units@comma{} libraries and smartlinking

The Free Pascal compiler supports smartlinking and the creation of
libraries. However, the default behavior is to compile each unit into
one big object file, which will be linked as a whole into your
program. Shared libraries can be created on most platforms, although
current level of FPC support may vary (they are e.g. not supported for
GO32v2 and OS/2 targets).  It is also possible to take existing units
and put them together in one static or shared library (using the
@command{ppumove} tool).

@node Reducing the size
@section Reducing the size of your program

When you created your program, it is possible to reduce the size of the
resulting executable. This is possible, because the compiler leaves a
lot of information in the program which, strictly speaking, isn’t
required for the execution of the program.

The surplus of information can be removed with a small program called
@command{strip}. The usage is simple.  Just type @command{strip prog} on
the command line, and the @command{strip} program will remove all
unnecessary information from your program. This can lead to size
reductions of up to 30%.  You can use the @option{-Xs} switch to let the
compiler do this stripping automatically at program compile time; the
switch has no effect when compiling units.

Another technique to reduce the size of a program is to use
smartlinking. Normally, units (including the system unit) are linked in
as a whole. It is however possible to compile units such that they can
be smartlinked. This means that only the functions and procedures that
are actually used are linked in your program, leaving out any
unnecessary code. The compiler will turn on smartlinking with the
@option{-XX} switch. This technique is described in full in the
programmers guide.
